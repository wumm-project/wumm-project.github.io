---
layout: default
title: 2020-10-20
---

# The TRIZ Ontology Project. Some Remarks

## About the difference between a data model and an ontology project

Most of our computer science students do not even understand the difference
between a __data model__ and a __database scheme__, but this is important, and
there are plenty of tools to transform a data model into a (even normalized)
data base scheme (at design time) and also much tools (e.g. the Hibernate
framework) to perform such a transformation at runtime.  This allows to work
with data abstraction layers (e.g. DAO) within the implementation and use a
general and a well defined persistence layer to organize all the storage
processes.

An ontology is such a data model that is widely accepted and can be used by
integrated tools as, e.g., the persistence layer framework within the
technology just mentioned. Hence an ontology is a __socially accepted__
standard and a __social process__ has to be passed through successfully.

What is the core of such a process. Take any TRIZ notion, e.g. "TRIZ methods".
It is a concept, but for the computer it is solely a wording without any
semantic meaning. The computer only understands, that the same wording at
different places means the same. Humans act differently, since they use at the
one hand in some cases the same wording for different meanings and in other
cases different wordings mean the same. NLP and ML is about that - to map
wordings on unique concepts (since the computer hardly can handle fuzzy
notions). Humans behave differently in another concern: they can good live
with notions that mean _almost_ the same. For computer use this has to be
"reduced to the essential", i.e. the "almost" has to be removed putting the
whole situation in a restricted contextualization (details are explained in my
TFC 2020 paper).

This (social!) process is called _formalization of the ontology_ and can be
done in a very informal way using plain text. To make the interchange more
machine readable the language itself, that is used for the description of the
model, has to be formalized in a __metamodel__.

This applies in particular the arrow labels in the model as "is related to"
(irt for short). If you have two such relations, as e.g.
irt(RTVModel,TRIZModel) and irt(ProjectActivity,TRIZModel) in the "TRIZ Model
Ontocard" (p. 9 of the TDS 2020 paper) one has to understand, what "is related
to" means, in particular, does it mean the same in both contexts.

First, I wrote the predicate irt as function with two arguments replacing
infix by prefix notation. Secondly, this are signatures, in the brackets the
_argument types_ are listed. In OO programming there is no problem to have the
same function name with different implementations. The correct function
(i.e. the appropriate pointer to the code) is chosen according to the type of
the arguments. Thus using the same function name a hidden unification process
is present that has to be made explicit on the level of the __metamodel__.
This, in its turn, can be done informally using plain text to explain to other
humans what the computer is doing.

But if you plan to automate also that process you need a language for the
language description, hence a __metametamodel__.  These three levels are
nowadays more or less standard in ontology modeling.

In many applications RDFS <https://www.w3.org/TR/rdf-schema/> is used as
metameta model, since it turned out that OWL <https://www.w3.org/OWL/> is much
to complicated for that (if the model is complex enough, it can be strictly
proven that OWL reasoning is undecidable). In many ontology modeling
applications nowadays SKOS <https://www.w3.org/TR/skos-reference/> is used as
such a metametamodel, although they claim "SKOS is not a formal knowledge
representation language" (cited from the website). This is indeed true, hence
a metametametamodel is required (in this case RDFS is used).

Hans-Gert Gr√§be, last update Oct. 20, 2020
